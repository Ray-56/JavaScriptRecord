# JS中对内存的一些了解
> 在JS进行开发的过程中, 了解JS内存机制有助于开发人员能够清晰的认识到自己写的代码在执行的过程中发生过什么, 也能够提高项目的代码质量.

## JS内存是怎么样的?
JS中变量存放有着原始值与引用值之分:
- 原始值: 原始的数据类型: `undefined`、`null`、`number`、`string`、`boolean`以及es6新加入的`symbol`.
- 引用值: `object`、`array`、`function`等类型的值便是引用值.

JS中的内存也分为栈内存和堆内存. [堆与栈](堆与栈.md) 详细了解查看这里.
eg:
```javascript
const str = '我是说明内存的文档'; // 这里 str 以及 '我的说明内存的文档' 都存储在栈内存当中
const obj = { a: 1 }; // 这里 obj(指向存储在堆中的数据的指针) 是存储在栈内存 而 { a: 1 } 则存储在堆当中
```

## 内存中的存储对象声明周期是怎么样的呢?
[MDN](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Memory_Management)中的介绍:
1. 当对象将被需要的时候为其分配内存.
2. 使用已分配的内存(读、写操作)
3. 当对象不再被需要的时候, 释放存储这个对象的内存
`1` `2`在所有语言中都是一样的, `3`在JS当中不是那么明显

## 看看内存中发生了什么?
```javascript
let str1 = 1; // 为str1分配栈内存 str1: 1
let str2 = str1; // 原始类型直接访问值, 即为str2新分配栈内存: str2: 1

str2 = 2; // 栈内存: str2: 2. str2的值为2, 而str1的值仍然是1

/************************ 我是分割线: 上面为原始类型 下面为复杂类型 *******************************/

let obj1 = { a: 1 }; // 为obj1分为栈内存访问地址的指针: obj1. 堆内存中存储对象值: { a: 1 }
let obj2 = obj1; // 为obj2分配栈内存访问地址的指针: obj2. 引用了堆内存中的值{ a: 1 }

obj2.a = 2; // 通过obj1修改堆内存的数据, 由于obj2与obj2都是指向堆内存中的同一个数据的指针(也叫引用). 所以堆内存中的值{a: 1}修改为{a: 2} 即 obj1.a 为 2; obj2.a 也为 2; (这里它们是指向了堆内存中的同一个数据的不同指针)

obj2 = { a: 3 }; // 因为改的是整个对象, 这里会在堆内存中创建一个新的对象值: {a:3}, 而obj2引用的是这个新对象, 所以obj1.a 依旧为 2; 而obj2.a 则为 3了. (这里它们是指向了堆内存中的不同数据的不同的指针)
```
然后看看这个问题:
```javascript
let a = { n: 1 };
let b = a;
a.x = a = { n: 2 };
```
具体查看[详细解释](http://www.cnblogs.com/huaan011/p/4381703.html), 对理解基础知识点还是很有帮助的. 例如: js的赋值运算顺序永远都是从右往左的，但是`.`是优先级最高的运算符. 

## 从内存角度看函数传值的变化
关于传值/址的解说. 用原始类型和引用类型来区分. 原始类型传的是值, 引用类型传的则为址.
```javascript
let str = '我是初始字符串';
let fn = (arg) => {
    console.log(arg); // #1 我是初始字符串

    arg = '我是修改后的字符串';
    console.log(arg); // #2 我是修改后的字符串
    console.log(str); // #3 我是初始字符串
};
fn(str);
```
上面例子`#1`可以看到传入`fn`的是`str`的值, 在栈内存中分配了新的空间来保存函数参数和其值(函数运行后自动释放这部分内存, _垃圾回收机制_). 所以在`#2`出输出的值为`我是修改后的字符串`. 在调用函数`fn`时给参数`arg`传了值(在栈内存中新分配的数据), 而`str`又为原始类型. 在`#3`处输出与初始化定义保持一致.

```javascript
let obj = { a: 1 };
let fn = (arg) => {
    arg = { a: 2 };
};

fn(obj);
// 这个时候obj还是{a: 1}

let fn1 = (arg) => {
    arg.a = 2;
};
fn1(obj);
// 这个时候obj则为{a: 2}
```
上面这个例子中的两个函数都是传址, 起初传入的参数`arg`都是引用(指向堆内存中的同一个数据的指针), 在`fn`中重新为变量`arg`赋值新的对象(引用类型). 而在`fn1`中的`arg`依旧是引用(指向堆内存中数据的指针), 所以`fn1`中是修改成功的.

## 垃圾回收机制
JS具有垃圾回收机制, 这给开发人员带来了极大的方便, 至少不用太考虑内存释放的问题(有部分还是要考虑的).
- 函数的变量只在函数执行过程中存在. 在函数执行过程中, 函数内部的变量将会在内存中分配一定的空间, 当函数执行完毕后, 自动将这些变量从内存中释放, 以留出空间作其它用处. 
- 当内存中某个变量不再被引用, JS将清理掉这部分内存的分配. eg:
```javascript
let obj = { a: 1 }; // 内存中存在{a: 1}对象, 以及obj这个引用地址
obj = { a: 2 }; // 垃圾回收机制自动清理{a: 1}, 并为新的有用的{a: 2}分配空间
```

## 内存优化
就全局变量而言, JS不能确定它在后面是否用到, 所有它从声明之后就一直存在于内存中, 直至手动释放或者关闭页面/浏览器, 这就导致了某些不必要的内存消耗. 我们可以进行以下优化.
__使用立即执行函数__
```javascript
(() => {
    // do something...
})();
```
__手动接触变量的引用__
```javascript
let obj = { a: 1, b: 2, c: 3 };
obj = null;
```
在JS中, 闭包是最容易产生内存问题的, 我们可以使用回调函数代替闭包来访问内部变量. 使用回调的好处就是(针对访问的内部变量时原始类型的值, 因为在函数传参的时候传的是值), 在执行后会自动释放其中的变量, 不会像闭包一样一直将内部变量存在于内存中(但如果是引用类型, 那么这个被引用的对象依旧在内存中).
```javascript
function fn() {
    var val = '你好';
    return function() {
            return val
        };
};
var getVal = fn();
var v = getVal(); // 你好
```
上面例子中, 虽然函数`fn`已经执行完毕, 但是对于函数中变量`val`的引用还在, 所以垃圾回收机制不会将函数中的`val`回收.

__使用回调__
```javascript
function fn1(cb) {
    var val = '你好';
    return cb(val);
};
function fn2(arg) {
    return arg;
};
var v = fn1(fn2);
```
同时声明, 并不是说明这样做就一定比闭包好, 闭包也有其好处, 只是需要我们在分清在最恰当的时候使用.


