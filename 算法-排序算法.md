> 对计算机中存储数据执行的两种最常见的操作是排序和检索, 自从计算机产业伊始便是如此. 这样意味着排序和检索在计算机科学中是被研究得最多的操作. 前面所讲到的许多数据结构, 都对排序和查找算法进行了专门的设计, 以使对其中的数据进行操作时更简洁高效.

> 下面介绍数据排序的基本算法和高级算法. 这些算法都只是依赖数组来存储数据. 我们还将一起看看几种计算程序运行时间的方法, 一遍确定哪种算法效率最高.

## 数组测试平台
将从开发一个数组测试平台开始, 它将辅助我们完成基本排序算法的研究. 我们将创建一个数组类和一些封装了常规数组操作的函数: 插入新数据, 显示数组数据及调用不同的排序算法. 这个类还包含了一个`swap()`方法, 用于交换元素.
```js
window.log = console.log.bind(console)

class CArray {
    constructor(numElements) {
        this.numElements = numElements;
        this.dataStore = [];
        this.pos = 0;
        for (let i = 0; i < numElements; i++) {
            this.dataStore[i] = i;
        };
    }
    setData() {
        for (let i = 0; i < this.numElements; i++) {
            this.dataStore[i] = Math.floor(Math.random() * (this.numElements + 1));
        };
    }
    clear() {
        for (let i = 0; i < this.numElements; i++) {
            this.dataStore[i] = 0;
        }
    }
    insert(element) {
        this.dataStore[this.pos++] = element;
    }
    toString() {
        let restr = '';
        for (let i = 0; i < this.dataStore.length; ++i) {
            restr += this.dataStore[i] + ' ';
            if (i > 0 && (i + 1) % 10 === 0) {
                restr += '\n';
            };
        };

        return restr;
    }
    swap(arr, index1, index2) {
        const temp = arr[index1];
        arr[index1] = arr[index2];
        arr[index2] = temp;
    }
};

const numElements = 100;
const myNums = new CArray(numElements);
myNums.setData();
log(myNums.toString());
```
输出结果:
```
50 60 69 76 53 27 19 79 8 70 
0 29 63 100 62 92 26 86 27 6 
4 8 85 87 31 56 33 8 37 31 
99 4 20 19 2 96 40 89 16 78 
74 41 62 38 12 6 46 25 93 50 
6 57 41 67 31 72 54 69 62 44 
14 43 8 50 70 9 26 81 78 15 
40 57 90 72 21 55 9 100 50 50 
66 30 27 68 74 26 94 83 37 40 
95 100 23 54 88 52 5 66 19 77 
```

## 基本排序算法
接下来要介绍的基本排序算法其核心思想是指对一组数据按照一定的顺序重新排列. 重新排列时用到的技术是一组嵌套的`for`循环. 其中外循环会遍历数组的每一项, 内循环则用于比较元素. 这些算法非常逼真地模拟了人类在现实生活中对数据的排序, 例如纸牌玩家在处理手中的牌时对纸牌进行排序, 或者教室按照字母顺序或者分数对试卷进行排序.

### 冒泡排序
我们先来了解一下 _冒泡排序_ , 它是最慢的排序算法之一, 但是也是一种最容易实现的排序算法.

之所以叫冒泡排序是因为使用这种排序算法排序时, 数据值会像气泡一样从数组的一段漂浮到另一端. 假设正在将一组数字按照升序排列, 较大的值会浮动到数组的右侧, 而较小的值则会浮动到数组的左侧. 之所以会产生这种现象是因为算法会多次在数组中移动, 比较相邻的数据, 当左侧值大于右侧值时将它们进行互换.
```js
window.log = console.log.bind(console)

class CArray {
    constructor(numElements) {
        this.numElements = numElements;
        this.dataStore = [];
        this.pos = 0;
        for (let i = 0; i < numElements; i++) {
            this.dataStore[i] = i;
        };
    }
    setData() {
        for (let i = 0; i < this.numElements; i++) {
            this.dataStore[i] = Math.floor(Math.random() * (this.numElements + 1));
        };
    }
    clear() {
        for (let i = 0; i < this.numElements; i++) {
            this.dataStore[i] = 0;
        }
    }
    insert(element) {
        this.dataStore[this.pos++] = element;
    }
    toString() {
        let restr = '';
        for (let i = 0; i < this.dataStore.length; ++i) {
            restr += this.dataStore[i] + ' ';
            if (i > 0 && (i + 1) % 10 === 0) {
                restr += '\n';
            };
        };

        return restr;
    }
    swap(arr, index1, index2) {
        const temp = arr[index1];
        arr[index1] = arr[index2];
        arr[index2] = temp;
    }
    // 冒泡排序
    bubbleSort() {
        for (let i = 0; i < this.dataStore.length; i++) { // 外循环多少次
            for (let j = 0; j < this.dataStore.length - i - 1; j++) { // 每一次外循环时比较多少次内循环
                if(this.dataStore[j] > this.dataStore[j + 1]) {
                    this.swap(this.dataStore, j, j + 1);
                }
            };
            log(this.toString())
        }
    }
};

const numElements = 10;
const myNums = new CArray(numElements);
myNums.setData();
log(myNums.toString());
myNums.bubbleSort();
log(myNums.toString());
```
我们在`bubbleSort()`中每一次加入`toSting()`这样就可以看到这个数组在排序过程中的当前状态.
通过这样输出结果, 我们可以更加容易看出小的值是如何移到数组开头的, 大的值又是如何移到数组末尾的. 下面这图更加清晰的展示了这一算法的完全过程:
![冒泡排序演示](https://github.com/guokangf/JavaScriptRecord/raw/master/images/bubbleSort.gif) </br>
[源码](./html/bubbleSort.html);

### 选择排序
接下来要看的是 _选择排序算法_. 选择排序从数组的开头开始, 将第一个元素和其他元素进行比较. 检查完所有元素后, 最小的元素会被放到数组的第一个位置, 然后算法会从第二个位置继续. 这个过程一直进行, 当进行到数组的倒数第二个位置时, 所有的数据便完成了排序.

选择循环会用到嵌套循环. 外循环从数组的第一个元素移动到倒数第二个元素; 内循环从第二个数组元素移动到最后一个元素, 查找比当前循环所指向的元素小的元素. 每次内循环迭代后, 数组中最的值都会被赋值到合适的位置.
```js
window.log = console.log.bind(console)

class CArray {
    constructor(numElements) {
        this.numElements = numElements;
        this.dataStore = [];
        this.pos = 0;
        for (let i = 0; i < numElements; i++) {
            this.dataStore[i] = i;
        };
    }
    setData() {
        for (let i = 0; i < this.numElements; i++) {
            this.dataStore[i] = Math.floor(Math.random() * (this.numElements + 1));
        };
    }
    clear() {
        for (let i = 0; i < this.numElements; i++) {
            this.dataStore[i] = 0;
        }
    }
    insert(element) {
        this.dataStore[this.pos++] = element;
    }
    toString() {
        let restr = '';
        for (let i = 0; i < this.dataStore.length; ++i) {
            restr += this.dataStore[i] + ' ';
            if (i > 0 && (i + 1) % 10 === 0) {
                restr += '\n';
            };
        };

        return restr;
    }
    swap(arr, index1, index2) {
        const temp = arr[index1];
        arr[index1] = arr[index2];
        arr[index2] = temp;
    }
    // 冒泡排序
    bubbleSort() {
        for (let i = 0; i < this.dataStore.length; i++) { // 外循环多少次
            for (let j = 0; j < this.dataStore.length - i - 1; j++) { // 每一次外循环时比较多少次内循环
                if(this.dataStore[j] > this.dataStore[j + 1]) {
                    this.swap(this.dataStore, j, j + 1);
                }
            };
            log(this.toString())
        }
    }
    // 选择排序
    async selectionSort() {
        let min;
        const { length } = this.dataStore;
        for (let outer = 0; outer < length - 1; outer++) { // 外循环多少次
            min = outer;
            for (let inner = outer + 1; inner < length; inner++) { // 每一次外循环时比较多少次内循环
                if(this.dataStore[inner] < this.dataStore[min]) {
                    min = inner;
                };
            };
            this.swap(this.dataStore, outer, min);
            log(this.toString())
        };
    }
};

const numElements = 10;
const myNums = new CArray(numElements);
myNums.setData();
log(myNums.toString());
myNums.selectionSort();
log(myNums.toString());
```
![选择排序演示](https://github.com/guokangf/JavaScriptRecord/raw/master/images/selectionSort.gif) </br>
[源码](./html/selectionSort.html);


